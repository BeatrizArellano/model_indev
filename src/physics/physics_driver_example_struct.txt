! src/physics/physics_driver.F90
module physics_driver
  use iso_fortran_env,  only: real64
  use tidal_parameters_from_file, only: TidalParams, read_tidal_parameters
  implicit none
  private

  !======================
  ! Public API
  !======================
  public :: physics_initialize      ! set up grid, parameters, state
  public :: physics_step            ! advance physics by one step
  public :: physics_finalize        ! release resources
  !public :: physics_get_grid        ! optional accessor(s)

  !======================
  ! Internal state
  !======================
  type :: Grid1D
     integer :: nz = 0
     real(real64), allocatable :: z(:)     ! cell centers [m]
     real(real64), allocatable :: dz(:)    ! layer thickness [m]
     real(real64), allocatable :: z_w(:)   ! interfaces (optional)
  end type

  type :: PhysParams
     real(real64) :: latitude
     real(real64) :: longitude
     real(real64) :: h      = 100.0_real64   ! depth [m], if needed
     real(real64) :: rho0   = 1025.0_real64
     ! add mixing coeff caps, Coriolis, etc.
  end type

  type :: PhysState
     real(real64), allocatable :: T(:)      ! temperature [°C]
     real(real64), allocatable :: S(:)      ! salinity [psu]
     real(real64), allocatable :: U(:), V(:)! currents [m/s]
     real(real64), allocatable :: Kz(:)     ! vertical diffusivity [m2/s]
     ! add more prognostics/diagnostics as you grow
  end type

  ! Module-scope singletons (encapsulated)
  type(Grid1D)     :: G
  type(PhysParams) :: P
  type(PhysState)  :: X
  type(TidalParams):: Tide
  logical          :: is_initialized = .false.

contains

  !======================
  ! Initialization
  !======================
  subroutine physics_initialize(cfg)
    ! cfg is your ConfigParams or similar
    type(*), intent(in) :: cfg  ! keep generic; you can 'use read_config_yaml' and set specific type if you prefer
    integer :: nz
    real(real64) :: lat, lon
    character(len=:), allocatable :: tide_file
    integer :: idx

    if (is_initialized) return

    ! ---- 1) Read site/config ----
    call get_num_from_cfg(cfg, 'main.location.latitude',  lat)
    call get_num_from_cfg(cfg, 'main.location.longitude', lon)
    call get_int_from_cfg(cfg, 'physics.grid.nz',         nz, default=50)
    call get_str_from_cfg(cfg, 'physics.tides.filename',  tide_file, default='tides.dat')

    P%latitude  = lat
    P%longitude = lon

    ! ---- 2) Build grid ----
    !call build_vertical_grid(nz, P%h, G)

    ! ---- 3) Allocate & set initial state ----
    !call allocate_state(G, X)
    !call set_initial_conditions(cfg, G, X)

    ! ---- 4) Read tidal parameters once ----
    call read_tidal_parameters(cfg, Tide)   ! wraps read_tides_at_point(...)
    ! Optionally precompute constituent omegas or per-layer tidal shear forcing, etc.

    ! ---- 5) Initialize turbulence/mixing scheme ----
    !call turbulence_init(cfg, G, P, X)

    is_initialized = .true.
  end subroutine physics_initialize

  !======================
  ! One time step
  !======================
 ! subroutine physics_step(dt, time_s)
 !   real(real64), intent(in) :: dt     ! [s]
 !   real(real64), intent(in) :: time_s ! absolute or since start [s]
!
 !   if (.not. is_initialized) stop 'physics_step called before physics_initialize()'
!
 !   ! 1) Apply external forcings (winds, heat fluxes, tides)
 !   call apply_surface_fluxes(time_s, dt, G, P, X)
 !   call apply_tidal_forcing(time_s, G, P, Tide, X)
!
 !   ! 2) Update turbulence and Kz
 !   call turbulence_update(time_s, dt, G, P, X)
!
 !   ! 3) Advect/diffuse prognostics (if physics owns scalars)
 !   call vertical_diffuse(dt, G, X%Kz, X%T)
 !   call vertical_diffuse(dt, G, X%Kz, X%S)
 !   call vertical_momentum(dt, G, P, X)
!
 !   ! 4) Boundary conditions (surface/bottom)
 !   call apply_boundary_conditions(time_s, G, P, X)
 ! end subroutine physics_step
!
  !======================
  ! Finalize
  !======================
  subroutine physics_finalize()
    if (.not. is_initialized) return
    call deallocate_state(X)
    call deallocate_grid(G)
    Tide = TidalParams()  ! lets allocatables inside tidy up via assignment
    is_initialized = .false.
  end subroutine physics_finalize

  !======================
  ! Accessors (optional)
  !======================
  subroutine physics_get_grid(G_out)
    type(Grid1D), intent(out) :: G_out
    G_out = G
  end subroutine physics_get_grid

  subroutine physics_get_tides(T_out)
    type(TidalParams), intent(out) :: T_out
    T_out = Tide
  end subroutine physics_get_tides

  !======================
  ! Helpers (internal)
  !======================
  subroutine build_vertical_grid(nz, H, Gout)
    integer,      intent(in)  :: nz
    real(real64), intent(in)  :: H
    type(Grid1D), intent(out) :: Gout
    integer :: k
    Gout%nz = nz
    allocate(Gout%z(nz), Gout%dz(nz), Gout%z_w(nz+1))
    ! simple uniform grid example (z positive downward)
    Gout%dz = H / real(nz,real64)
    Gout%z_w(1) = 0.0_real64
    do k=2, nz+1
      Gout%z_w(k) = Gout%z_w(k-1) + Gout%dz(1)
    end do
    do k=1, nz
      Gout%z(k) = 0.5_real64*(Gout%z_w(k)+Gout%z_w(k+1))
    end do
  end subroutine build_vertical_grid

  subroutine allocate_state(Gin, Xin)
    type(Grid1D),  intent(in)  :: Gin
    type(PhysState),intent(out) :: Xin
    allocate(Xin%T(Gin%nz), Xin%S(Gin%nz), Xin%U(Gin%nz), Xin%V(Gin%nz), Xin%Kz(Gin%nz))
    Xin%T  = 10.0_real64
    Xin%S  = 35.0_real64
    Xin%U  = 0.0_real64
    Xin%V  = 0.0_real64
    Xin%Kz = 1.0e-4_real64
  end subroutine allocate_state

  subroutine deallocate_state(Xin)
    type(PhysState), intent(inout) :: Xin
    if (allocated(Xin%T))  deallocate(Xin%T)
    if (allocated(Xin%S))  deallocate(Xin%S)
    if (allocated(Xin%U))  deallocate(Xin%U)
    if (allocated(Xin%V))  deallocate(Xin%V)
    if (allocated(Xin%Kz)) deallocate(Xin%Kz)
  end subroutine deallocate_state

  subroutine deallocate_grid(Gin)
    type(Grid1D), intent(inout) :: Gin
    if (allocated(Gin%z))   deallocate(Gin%z)
    if (allocated(Gin%dz))  deallocate(Gin%dz)
    if (allocated(Gin%z_w)) deallocate(Gin%z_w)
    Gin%nz = 0
  end subroutine deallocate_grid

  ! ----- Stubs to fill in with your existing code -----
  subroutine get_num_from_cfg(cfg, key, val, default)
    type(*), intent(in) :: cfg
    character(len=*), intent(in) :: key
    real(real64), intent(out) :: val
    real(real64), intent(in), optional :: default
    ! replace with your read_config_yaml getters
    if (present(default)) then
      val = default
    else
      val = 0.0_real64
    end if
  end subroutine

  subroutine get_int_from_cfg(cfg, key, val, default)
    type(*), intent(in) :: cfg
    character(len=*), intent(in) :: key
    integer, intent(out) :: val
    integer, intent(in), optional :: default
    if (present(default)) then
      val = default
    else
      val = 0
    end if
  end subroutine

  subroutine get_str_from_cfg(cfg, key, val, default)
    type(*), intent(in) :: cfg
    character(len=*), intent(in) :: key
    character(len=:), allocatable, intent(out) :: val
    character(len=*), intent(in), optional :: default
    if (present(default)) then
      val = default
    else
      val = ''
    end if
  end subroutine

  subroutine set_initial_conditions(cfg, G, X)
    type(*),       intent(in) :: cfg
    type(Grid1D),  intent(in) :: G
    type(PhysState),intent(inout) :: X
    ! hook to load from file or simple profiles
  end subroutine

  subroutine turbulence_init(cfg, G, P, X)
    type(*), intent(in) :: cfg
    type(Grid1D),  intent(in) :: G
    type(PhysParams), intent(in) :: P
    type(PhysState), intent(inout) :: X
    ! init your chosen scheme (k-e, k-ε, S2P3 original, etc.)
  end subroutine

  subroutine turbulence_update(t, dt, G, P, X)
    real(real64),  intent(in) :: t, dt
    type(Grid1D),  intent(in) :: G
    type(PhysParams), intent(in) :: P
    type(PhysState), intent(inout) :: X
    ! compute Kz, etc.
  end subroutine

  subroutine vertical_diffuse(dt, G, Kz, Y)
    real(real64), intent(in) :: dt
    type(Grid1D), intent(in) :: G
    real(real64), intent(in) :: Kz(:)
    real(real64), intent(inout) :: Y(:)
    ! your diffusion scheme (tri-di solver / implicit etc.)
  end subroutine

  subroutine vertical_momentum(dt, G, P, X)
    real(real64), intent(in) :: dt
    type(Grid1D), intent(in) :: G
    type(PhysParams), intent(in) :: P
    type(PhysState), intent(inout) :: X
    ! momentum tendencies, bottom stress, etc.
  end subroutine

  subroutine apply_surface_fluxes(t, dt, G, P, X)
    real(real64), intent(in) :: t, dt
    type(Grid1D), intent(in) :: G
    type(PhysParams), intent(in) :: P
    type(PhysState), intent(inout) :: X
    ! wind stress, heat flux, buoyancy, shortwave
  end subroutine

  subroutine apply_boundary_conditions(t, G, P, X)
    real(real64), intent(in) :: t
    type(Grid1D), intent(in) :: G
    type(PhysParams), intent(in) :: P
    type(PhysState), intent(inout) :: X
    ! surface/bottom BCs, no-flux or specified fluxes
  end subroutine

  subroutine apply_tidal_forcing(t, G, P, Tide, X)
    real(real64), intent(in) :: t
    type(Grid1D), intent(in) :: G
    type(PhysParams), intent(in) :: P
    type(TidalParams), intent(in) :: Tide
    type(PhysState), intent(inout) :: X
    ! convert (SEMA,SEMI,INC,PHA) into U/V tidal currents at time t
    ! and add to momentum/ mixing as appropriate
  end subroutine

end module physics_driver
